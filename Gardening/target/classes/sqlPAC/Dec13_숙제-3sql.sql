

SELECT
		NO 번호
, MIN(ST_DT) 시작날짜
, MAX(ET_DT) 종료날짜
, MIN(NM)  이름
FROM 
( 
SELECT  NO, NM, ST_DT, ET_DT
			, SUM(HH) OVER(PARTITION BY NO ORDER BY NO, ST_DT) SS
FROM 
(

		SELECT 	NO  ,NM
						,  ST_DT
						,  ET_DT
						,  CASE WHEN ST_DT
									<= MAX(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)
								  THEN 0 ELSE 1 END HH
						, MAX(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)  MA
			FROM ORG_TBL
			ORDER BY NO, ST_DT  
		) 
	)
GROUP BY NO, SS
ORDER BY NO, SS
;

----------------



-- 범위를 같다 아니다로 하니까 달라짐.. 



SELECT
		NO 번호
, MIN(ST_DT) 시작날짜
, MAX(ET_DT) 종료날짜
, MIN(NM)  이름
FROM 
( 
SELECT  NO, NM, ST_DT, ET_DT
			, SUM(DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT) S_DT   --누적합..
							-- 다를때 1이니까. 겹치는건 한번호로 묶일거임 
			, DT
			, MA
			
FROM 
(
		SELECT 	NO  ,  NM
						,  ST_DT
						,  ET_DT
						,  CASE WHEN ST_DT
									<= LAG(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT )
								  THEN 0 ELSE 1 END DT
						, LAG(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT ) MA  -- 이전의 ET_DT합 
			FROM ORG_TBL
			ORDER BY NO, ST_DT   
		)  
	)
GROUP BY NO , S_DT
ORDER BY NO;







-----------


		SELECT 	NO  ,NM
						,  ST_DT
						,  ET_DT
						,  CASE WHEN ST_DT
									<= LAG(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT )
								  THEN 0 ELSE 1 END HH
						, MAX(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)  MA
			FROM ORG_TBL
			ORDER BY NO, ST_DT  ;


-- 숙제
-- 이순신 하나가 안나옴 범위를 A 나 B 나 NULL 로 되어있어서 한번에 잡혀서 다 묶여버림..
SELECT 
     RTRIM(MAX(NO))  번호
 	, RTRIM(ST_DT1) 시작일자
 	, RTRIM(ET_DT1) 종료일자
 	, RTRIM(MAX(NM)) 이름
 FROM
(
SELECT
	NO, NM, ST_DT, ET_DT                
	, DECODE(SEQ || SEW, 'BA', ST_DT
		,'B', ST_DT
		, MIN(ST_DT) OVER(PARTITION BY NM  ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING))  ST_DT1
	, DECODE(SEQ || SEW, 'BA', ET_DT
	, 'A',  ET_DT
	,  MAX(ET_DT) OVER(PARTITION BY NM  ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING))  ET_DT1
	, SEQ
	, SEW
	, SEQ || SEW
FROM(

		SELECT 	NO  ,NM
						,  ST_DT
						,  ET_DT
						,  DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT) ,NULL , 'A') SEW
						,  DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), NULL, 'B') SEQ
			FROM ORG_TBL
			ORDER BY NO, ST_DT   
		)
)

GROUP BY (ST_DT1, ET_DT1)		
ORDER BY ST_DT1
;

	
------------------------------------------------------------

 	
 	
 	
 	
 	
 SELECT 
     RTRIM(MAX(NO))  번호
 	, RTRIM(ST_DT1) 시작일자
 	, RTRIM(ET_DT1) 종료일자
 	, RTRIM(MAX(NM)) 이름
 FROM
(
;
SELECT
	NO, NM, ST_DT, ET_DT  , SEQ          
	, DECODE(SEQ, 'AB', ST_DT, 'B', ST_DT
	, 'A', DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), LAG(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), NULL)
		, MIN(ST_DT) OVER(PARTITION BY NM  ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING))  ST_DT1
		
	, DECODE(SEQ, 'AB', ET_DT, 
	 'A',  ET_DT 
	 , 'B' , DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), LEAD(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), NULL)
	,  MAX(ET_DT) OVER(PARTITION BY NM  ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING))  ET_DT1

;


SELECT 
	NO, NM, ST_DT, ET_DT  , SEQ          
	, DECODE(SEQ, NULL, ST_DT
				, 'A', ST_DT
				, 'B', ET_DT
				, NULL ) ST_DT1
	, DECODE(SEQ, NULL, ET_DT
				, 'B', ET_DT
				,'A', DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT), LEAD(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT))
				, NULL )  ET_DT1
FROM(
		SELECT 	NO  ,NM
						,  ST_DT
						,  ET_DT
						,  DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT) ,'A' , NULL )
								 ||   DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), 'B', NULL) SEQ
			FROM ORG_TBL
			ORDER BY NO, ST_DT   
		) WHERE SEQ != 'AB' OR SEQ IS NULL ;
)

GROUP BY (ST_DT1, ET_DT1)		
ORDER BY ST_DT1
;
 	
------------------------------------------------------------


SELECT
		NO , MAX(NM)
, MIN(ST_DT) ST_DT 
, MAX(ET_DT) ST_DT
FROM 
( 
SELECT  NO, NM, ST_DT, ET_DT
			, SUM(HH) OVER(PARTITION BY NO ORDER BY NO, ST_DT) SS
FROM 
(
		SELECT 	NO  ,NM
						,  ST_DT
						,  ET_DT
						,  CASE WHEN ST_DT
									<= MAX(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT, ET_DT ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING)
								  THEN 0 ELSE 1 END HH
							
			FROM ORG_TBL
			ORDER BY NO, ST_DT  
		)
	)
GROUP BY NO, SS
ORDER BY NO, SS
		 ;



 	
 	
 

 	
 	
 	
------------------------------------------------------------


	SELECT 	NO  ,NM
						,  ST_DT
						,  ET_DT
						,  DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT) ,NULL , 'A') SEW
						,  DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), NULL, 'B') SEQ
			FROM ORG_TBL
			ORDER BY NO, ST_DT;

;
	
	
	
------------------------------------------------------------


-- 토요일
	
	
	
SELECT 
     RTRIM(MAX(NO))  번호
 	, RTRIM(ST_DT1) 시작일자
 	, RTRIM(ET_DT1) 종료일자
 	, RTRIM(MAX(NM)) 이름
 FROM
(	;
	SELECT
	NO, NM, ST_DT, ET_DT
		-- SEQ 가 00인것부터 11까지 첫번째 ST_DT와 마지막 ET_DT 를 구하면 될듯 (NM으로 PARTITION BY 해줘서)      
		-- REGEXP_SUBSTR(  '1 포함하면 
	, DECODE(SEQ, '10', ST_DT
						, '01', MIN(ST_DT) OVER(PARTITION BY NM  ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
						, MIN(ST_DT) OVER(PARTITION BY NM  ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING))   ST_DT1
	
	, DECODE(SEQ, '10', ET_DT
						, '01', MAX(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
						--, '01',  LAST_VALUE(ET_DT) OVER(PARTITION BY NM  ORDER BY NO, ST_DT  RANGE BETWEEN '00' PRECEDING AND '11' FOLLOWING) 
						, MAX(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING))   ST_DT1
	, SEQ
	, LEAD_A
	, LAG_B
FROM(  
		SELECT 	NO  ,NM 
						,  ST_DT
						,  ET_DT
						,  DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT), '0', '1') ||       
						  DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), '1' , '0')    SEQ
						,  DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT), '0' , '1') LEAD_A  
						,  DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), '1' , '0') LAG_B
			FROM ORG_TBL
			ORDER BY NO, ST_DT      
) ;
)
GROUP BY (ST_DT1, ET_DT1)		
ORDER BY ST_DT1
;	
	
	
-----------------------------------------------------------	



-- RANK 이용



SELECT 
	 MAX(NO) 번호
	 , NEW_ST  시작일자
	 , NEW_ET  종료일자
	  , MAX(NM) 이름

FROM
(
SELECT NO, NM 
	,  DECODE(RK, 1 , ST_DT
						, 3, DECODE(LAG(ST_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT, RK)
							, NULL, ST_DT, LAG(ST_DT) OVER(PARTITION BY NO ORDER BY NO))   
					  	,4, LAG(ST_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT, RK)) 
				NEW_ST
	
	, DECODE(RK, 3, ET_DT , 1, DECODE(LEAD(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT, RK)
					 	, NULL, ET_DT, LEAD(ET_DT) OVER(PARTITION BY NO ORDER BY NO))
						, 4, ET_DT)
				 NEW_ET
	
	, SEQ, RK
FROM
(
SELECT   
	NO, NM, ST_DT, ET_DT, SEQ
	, DENSE_RANK() OVER(PARTITION BY NO ORDER BY  SEQ ) RK
FROM
(  
	SELECT 	NO  ,NM 
						,  ST_DT
						,  ET_DT
						,  DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT), '0', '1') ||       
						  DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NM ORDER BY NO, ST_DT ), '1' , '0')    SEQ
			FROM ORG_TBL
			ORDER BY NO, ST_DT      
			
)
ORDER BY NO, ST_DT, RK   
)
)
GROUP BY (NEW_ST, NEW_ET)
ORDER BY 번호, 시작일자
;














---------------------------------------------


SELECT 
	NO, NM,
	  A , B
	, DECODE(A, B, DECODE(LAG(A) OVER(ORDER BY NO, ST_DT), NULL, A,  LAG(A) OVER(ORDER BY NO, ST_DT))
					, A)   ST_DT1
	, DECODE(A, B, DECODE(LEAD(B) OVER(ORDER BY NO, ST_DT), NULL, B, LEAD(B) OVER(ORDER BY NO, ST_DT))
					, B) ET_DT1
FROM
(

;


SELECT 
	NO, NM
	, ST_DT, S1, ET_DT
	, DECODE(ST_DT, S1, ST_DT, NULL)
	, DECODE(ET_DT, S2, ET_DT, S1, S1, NULL)
	
FROM
(
SELECT 
		MAX(NO)  NO
	, MAX(NM) NM
	, ST_DT, ET_DT
	, S1, S2
FROM 
(
SELECT 
	NO, NM, ST_DT, ET_DT
	, DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL , NULL, ST_DT, ST_DT) A
	, DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL , NULL, ET_DT, ET_DT) B
	, DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL , NULL, ST_DT, ST_DT) 
	    || 'B' || DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL , NULL, ET_DT, ET_DT) C
	     
	, REGEXP_SUBSTR( DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL, NULL, ST_DT, ST_DT) 
	     || 'B' || DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL , NULL, ET_DT, ET_DT)
	     ,  '[^B]+' , 1, 1) S1
	, REGEXP_SUBSTR( DECODE(ST_DT, LAG(ET_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL, NULL, ST_DT, ST_DT) 
	     || 'B' || DECODE(ET_DT, LEAD(ST_DT) OVER(PARTITION BY NO ORDER BY NO, ST_DT), NULL , NULL, ET_DT, ET_DT)
	     ,  '[^B]+' , 1, 2) S2
FROM ORG_TBL
ORDER BY NO, ST_DT  
) 
WHERE S1 IS NOT NULL
GROUP BY (ST_DT, ET_DT, S1, S2)
ORDER BY NO , ST_DT
) 
;












